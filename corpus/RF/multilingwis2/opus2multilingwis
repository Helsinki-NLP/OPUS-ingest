#!/bin/env perl
#-*-perl-*-

use strict;
use vars qw($opt_d);
use Getopt::Std;
use File::Basename;
use XML::Parser;

getopts('d:');

my $DocIdFile = shift(@ARGV);
my $SentIdFile = shift(@ARGV);
my $WordIdFile = shift(@ARGV);

my $SentAlignFile = shift(@ARGV);
my $WordAlignFile = shift(@ARGV);

my $CorpusDir = $opt_d;
unless ($opt_d){
    $CorpusDir = $SentAlignFile;
    $CorpusDir=~s/\/wordalign\/.*$/\/parsed/;
}

binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");



# read file with unique doc ids
my %docid=();
open F,"<$DocIdFile" || die "cannot open $DocIdFile";
while (<F>){
    chomp;
    my ($id,$file) = split(/\t/);
    $docid{$file} = $id;
}
close F;

# read file with unique sentence ids
my @sentid=();
open F,"<$SentIdFile" || die "cannot open $SentIdFile";
while (<F>){
    chomp;
    my ($id,$file,$sid) = split(/\t/);
    next if (not exists $docid{$file});
    my $doc = $docid{$file};
    $sentid[$doc]{$sid} = $id;
}
close F;

# read file with unique word ids
my @wordid=();
open F,"<$WordIdFile" || die "cannot open $WordIdFile";
while (<F>){
    chomp;
    my ($id,$file,$sid) = split(/\t/);
    next if (not exists $docid{$file});
    my $doc = $docid{$file};
    $wordid[$doc]{$sid} = $id;
}
close F;




open S,"gzip -cd <$SentAlignFile |" || die "cannot read from $SentAlignFile";
open W,"gzip -cd <$WordAlignFile |" || die "cannot read from $WordAlignFile";

my $srcdoc=undef;
my $trgdoc=undef;

my $sdocid=undef;
my $tdocid=undef;

my %srcalg = ();
my %trgalg = ();

# avoid printing the same sentence twice
my %done = ();

while (<S>){
    chomp;
    my ($sdoc,$tdoc,$sids,$tids) = split(/\t/);
    my @src = split(/\s+/,$sids);
    my @trg = split(/\s+/,$tids);

    my $walign = <W>;
    chomp $walign;

    # skip non 1-1 alignments
    # next if ($#src != 0);
    # next if ($#trg != 0);

    if ($sdoc ne $srcdoc){
	die "no ID for $sdoc" unless (exists $docid{$sdoc});
	$sdocid = $docid{$sdoc};
	if ($srcdoc){
	    my @sent = ();
	    ReadDocument($srcdoc,\@sent);
	    AddAlignment($docid{$srcdoc},$docid{$trgdoc},\@sent,\%srcalg);
	    PrintSentences($srcdoc,\@sent);
	    ## read and convert srcdoc with alignments
	    %srcalg = ();
	}
	$srcdoc = $sdoc;
    }
    if ($tdoc ne $trgdoc){
	die "no ID for $tdoc" unless (exists $docid{$tdoc});
	$tdocid = $docid{$tdoc};
	if ($trgdoc){
	    my @sent = ();
	    ReadDocument($trgdoc,\@sent);
	    AddAlignment($docid{$srcdoc},$docid{$trgdoc},\@sent,\%srcalg,1);
	    PrintSentences($trgdoc,\@sent);
	    ## read and convert srcdoc with alignments
	    %srcalg = ();
	}
	$trgdoc = $tdoc;
    }

    foreach my $s (@src){
	$srcalg{$s}[0] = $sids;
	$srcalg{$s}[1] = $tids;
	$srcalg{$s}[2] = $walign;
    }
    foreach my $t (@trg){
	$srcalg{$t}[0] = $sids;
	$srcalg{$t}[1] = $tids;
	$srcalg{$t}[2] = $walign;
    }
}


if ($srcdoc){
    my @sent = ();
    ReadDocument($srcdoc,\@sent);
    AddAlignment($docid{$srcdoc},$docid{$trgdoc},\@sent,\%srcalg);
    PrintSentences($srcdoc,\@sent);
}
if ($trgdoc){
    my @sent = ();
    ReadDocument($trgdoc,\@sent);
    AddAlignment($docid{$srcdoc},$docid{$trgdoc},\@sent,\%srcalg,1);
    PrintSentences($trgdoc,\@sent);
}



sub PrintSentences{
    my ($doc,$sent) = @_;
    my $did = $docid{$doc};
    my $lang = $doc;
    $lang =~s/^([a-z]+)\/.*$/$1/;
    foreach my $s (@{$sent}){
	my $sid = $sentid[$did]{$$s[0][9]};
	next if ($done{$sid});
	foreach my $w (0..$#{$s}){
	    my $wid = $wordid[$did]{$$s[$w][8]};
	    if ($done{$wid}){
		print STDERR "Word $wid already done?! (skip sentence $sid)\n";
		next;
	    }
	    $done{$wid}++;
	    $$s[$w][8] = $wid;
	    $$s[$w][9] = $sid;
	    $$s[$w][10] = $did;
	    $$s[$w][11] = 0;
	    $$s[$w][12] = $lang;
	    $$s[$w][14] = '{}';
	    print join("\t",@{$$s[$w]});
	    print "\n";
	}
	$done{$sid}++;
#	print "\n";
    }
}


sub AddAlignment{
    my ($sdocid,$tdocid,$sent,$alg,$reverse) = @_;
    foreach my $s (@{$sent}){
	my $sid = $$s[0][9];
	next unless (exists $$alg{$sid});
	
	## get all word alignments
	my @alg = split(/\s+/,$$alg{$sid}[2]);
	my %links = ();
	foreach my $a (@alg){
	    my ($s,$t) = split(/\-/,$a);
	    ($s,$t) = ($t,$s) if ($reverse);
	    $links{$s}{$t} = 1;
	}

	## get all word IDs for all aligned sentences
	## NOTE: assume that we have regular IDs that correspond
	##       to sentence IDs ---> DANGEROUS!

	my @tids = split(/\s+/,$$alg{$sid}[1]);
	if ($#tids){
	    print '';
	}
	my @wids = ();
	foreach my $id (@tids){
	    $id =~s/^s/w/;
	    my $wnr = 1;
	    while (exists $wordid[$tdocid]{"$id.$wnr"}){
		push(@wids,"$id.$wnr");
		$wnr++;
	    }
	}

	## run through all words in the current sentence
	foreach my $w (0..$#{$s}){
	    unless (exists $links{$w}){
		$$s[$w][13] = '0';         ## TODO: is that OK?
		next;
	    }
	    my @links = ();
	    foreach my $l (sort {$a <=> $b} keys %{$links{$w}}){
		if ($wordid[$tdocid]{$wids[$l]}){
		    push(@links,$wordid[$tdocid]{$wids[$l]});
		}
		else{
		    print STDERR "no id found for token $l ($wids[$l]) in doc $tdocid sent $$alg{$sid}[1]\n";
		}
	    }
	    $$s[$w][13] = join('|',@links);
	    $$s[$w][13] = '0' unless ($$s[$w][13]);  ## TODO: is that OK?
	}
    }
}


sub ReadDocument{
    my ($doc,$sent) = @_;

    my $XmlParser = new XML::Parser(Handlers => {Start => \&XmlTagStart,
						 End => \&XmlTagEnd,
						 Default => \&XmlChar});
    my $XmlHandle = $XmlParser->parse_start;
    $XmlHandle->{SENT} = $sent;

    open F,"gzip -cd <$CorpusDir/$doc |" || die "cannot read from $doc";

    while (<F>){
    	eval { $XmlHandle->parse_more($_); };
    	if ($@){
    	    warn $@;
    	    print STDERR $_;
    	}
    }
    close F;
}

sub XmlTagStart{
    my ($p,$e,%a)=@_;
    if ($e eq 's'){
	$$p{SID} = $a{id};
	my $idx = @{$$p{SENT}};
	$$p{SENT}[$idx] = [];
    }
    elsif ($e eq 'w'){
	my $idx = @{$$p{SENT}[-1]};
	$$p{SENT}[-1][$idx][0] = $idx+1;
	$$p{SENT}[-1][$idx][2] = $a{lemma};
	$$p{SENT}[-1][$idx][3] = $a{upos};
	$$p{SENT}[-1][$idx][4] = $a{xpos};
	$$p{SENT}[-1][$idx][5] = $a{feats} ? $a{feats} : '_';
	$$p{SENT}[-1][$idx][6] = $a{head};
	$$p{SENT}[-1][$idx][7] = $a{deprel};
	$$p{SENT}[-1][$idx][8] = $a{id};
	$$p{SENT}[-1][$idx][9] = $$p{SID};
	$$p{WID}{$a{id}} = $idx+1;
	$$p{OPENW} = 1;
    }
}

sub XmlChar{
    my ($p,$c)=@_;
    if ($$p{OPENW}){
	$$p{WORD}.=$c;
    }
}

sub XmlTagEnd{
    my ($p,$e)=@_;
    if ($e eq 'w'){
	$$p{WORD}=~s/^\s*//;
	$$p{WORD}=~s/\s*$//;
	$$p{SENT}[-1][-1][1] = $$p{WORD};
	$$p{WORD} = '';
	$$p{OPENW} = 0;
    }
    elsif ($e eq 's'){
     	foreach my $w (@{$$p{SENT}[-1]}){
     	    if ($$w[6]){
     		$$w[6] = $$p{WID}{$$w[6]};
     	    }
     	}
     	delete $$p{WID};
    }
}

