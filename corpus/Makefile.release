# -*-makefile-*-
#
#
# set CORPUS to specify the corpus to operate on
# data will be taken from OPUSHOME/corpus/CORPUS
# and released in OPUSRELEASE/CORPUS
#
#----------------------------------------------
# creating release packages
#----------------------------------------------
#
#  make release ........ make all release packages
#
#
# individual packages:
#
#  make alg_files ...... XCES alignment files (just copy)
#  make lang_raw ....... language-specific data files in XML (untokenized)
#  make lang_xml ....... language-specific data files in XML (tokenized)
#  make lang_parsed .... language-specific data files in XML (parsed)
#
#  make tmx ............ bitexts in TMX
#  make moses .......... bitexts in aligned plain text (Moses format)
#
#  make mono_raw ....... monolingual plain text files (untokenized)
#  make mono_tok ....... monolingual plain text files (tokenized)
#  make freq_counts .... token frequency counts per language
#
#  make smt ............ SMT phrase tables and related filed
#  make wordalg ........ statistical word alignment files
#  make dic-release .... bilingual dictionaries from word alignment
#
#----------------------------------------------
# releasing data
#----------------------------------------------
#
#  make publish-release .. publish the release (allas, ida, OPUS server and git update)
#  make upload-release ... upload the release (allas and OPUS server)
#
#
# individual steps:
#
#  make upload ........... upload data to allas
#  make upload-ida ....... upload data to IDA
#  make upload-website ... upload website and data sample files to OPUS server
#  make upload-cwb ....... upload CWB corpus index to OPUS server (if it exists)
#  make update-git ....... update git repo
#  make release-nlpl ..... copy data to NLPL space (not anymore - space is full)
#
#
# website related things:
#
#  make website ........ make corpus website
#  make alg_samples .... bitext sample files
#  make corpus_samples . corpus sample files
#  make html ........... make website and counts
#  make refresh-html ... remove old html and make new
#
#
# statistics and info files
#
#  make info ........... info files and statistics (individual steps below)
#  make lang_info
#  make ces_info
#  make txt_info
#  make tmx_info
#
#
#----------------------------------------------
# NEW (ATTENTION - this is potentially very dangerous!)
#----------------------------------------------
#
#  make delete-empty-bitexts
#  make delete-empty-corpora
#
#----------------------------------------------


## language pairs and bitext release files

CES       ?= $(wildcard ${CORPUSXML}/*.xml.gz)
LANGPAIRS ?= $(patsubst ${CORPUSXML}/%.xml.gz,%,${CES})
ALG       := $(patsubst ${CORPUSXML}/%,${CORPUSRELEASE}/xml/%,$(CES))
TMX       := $(patsubst ${CORPUSXML}/%.xml.gz,${CORPUSRELEASE}/tmx/%.tmx.gz,$(CES))
MOSES     := $(patsubst ${CORPUSXML}/%.xml.gz,${CORPUSRELEASE}/moses/%.txt.zip,$(CES))
DIC       := $(patsubst ${CORPUSHOME}/%,${CORPUSRELEASE}/%,$(wildcard ${CORPUSDIC}/*.dic.gz))

## strict = bitexts with "high-quality" alignments only (1:1, hunalign link score > 1)
TMX_STRICT    := $(patsubst ${CORPUSXML}/%.xml.gz,${CORPUSRELEASE}/tmx/%.strict.tmx.gz,$(CES))
MOSES_STRICT  := $(patsubst ${CORPUSXML}/%.xml.gz,${CORPUSRELEASE}/moses/%.strict.txt.zip,$(CES))


## monolingual release files

LANG_XML   := $(patsubst %,${CORPUSRELEASE}/xml/%.zip,${LANGUAGES})
LANG_RAW   := $(patsubst %,${CORPUSRELEASE}/raw/%.zip,${LANGUAGES})
LANG_UD    := $(patsubst %,${CORPUSRELEASE}/parsed/%.zip,${PARSED_LANGUAGES})
MONO_TOK   := $(patsubst %,${CORPUSRELEASE}/mono/%.tok.gz,${LANGUAGES})
MONO_RAW   := $(patsubst %,${CORPUSRELEASE}/mono/%.txt.gz,${LANGUAGES})
MONO_DEDUP := $(patsubst %,${CORPUSRELEASE}/mono/%.dedup.gz,${LANGUAGES})


# info files with various counts

CES_INFO  := $(patsubst ${CORPUSRELEASE}/xml/%.xml.gz,${CORPUSRELEASE}/info/%.info,$(wildcard ${CORPUSRELEASE}/xml/*.xml.gz))
TXT_INFO  := $(patsubst ${CORPUSRELEASE}/moses/%.txt.zip,${CORPUSRELEASE}/info/%.txt.info,$(wildcard ${CORPUSRELEASE}/moses/*.txt.zip))
TMX_INFO  := $(patsubst ${CORPUSRELEASE}/tmx/%.tmx.gz,${CORPUSRELEASE}/info/%.tmx.info,$(wildcard ${CORPUSRELEASE}/tmx/*.tmx.gz))
LANG_INFO := $(patsubst %,${CORPUSRELEASE}/info/%.info,${LANGUAGES})

## word frequency counts

FREQ_COUNTS := $(patsubst %,${CORPUSRELEASE}/freq/%.freq.gz, ${LANGUAGES})


## sample files in HTML

ALG_SAMPLES    = $(patsubst ${CORPUSXML}/%.xml.gz,${CORPUSPUB}/%_sample.html, ${CES})
CORPUS_SAMPLES = $(patsubst %,${CORPUSPUB}/%_sample.html, ${LANGUAGES})
SAMPLE_FILES   = ${ALG_SAMPLES} ${CORPUS_SAMPLES}


# languages with parsed data

ifneq ($(wildcard ${CORPUSPARSED}),)
  PARSED_LANGUAGES ?= $(sort $(notdir \
	$(shell find ${CORPUSPARSED} -maxdepth 1 -mindepth 1 -type d)))
endif


# SMT phrase-tables and word alignment files

SMT ?= $(patsubst ${CORPUSWORDALIGN}/%/bitext.xml.gz,${CORPUSRELEASE}/smt/%.zip,\
	          ${wildcard ${CORPUSWORDALIGN}/*/bitext.xml.gz})
WORDALG ?= $(patsubst %.zip,%.alg.zip,${SMT})


##-------------------------------------------------------------------
## selection of packages to be released
## NEW: reduce packages if we have > 10,000 bitexts in the corpus
## TODO: this does not work when running individual release jobs
##       for each language and language pair
##-------------------------------------------------------------------

REDUCED_PACKAGES   := ${ALG} ${LANG_XML} ${LANG_RAW} ${LANG_UD} \
			${MONO_RAW} ${MONO_TOK} ${FREQ_COUNTS}
REDUCED_INFOFILES  := ${LANG_INFO} ${CES_INFO}
STANDARD_PACKAGES  := ${REDUCED_PACKAGES} $(MOSES) $(TMX) ${SMT} ${WORDALG} ${DIC}
STANDARD_INFOFILES := ${REDUCED_INFOFILES} ${TXT_INFO} ${TMX_INFO}

ifeq ($(shell test $(words ${CES}) -gt 10000; echo $$?),0)
  SELECTED_PACKAGES := ${REDUCED_PACKAGES}
  INFOFILES         := ${REDUCED_INFOFILES}
else
  SELECTED_PACKAGES := ${STANDARD_PACKAGES}
  INFOFILES         := ${STANDARD_INFOFILES}
endif


## skip all XML and derived files (basically just leaving moses and TMX)

ifdef SKIP_XML_FILES
  SELECTED_PACKAGES = $(MOSES) $(TMX)
  INFOFILES = ${TXT_INFO} ${TMX_INFO}
endif


## skip tokenized files
## TODO: reduced packages for corpora with many languages!
## TODO: ces_info and lang_info are not correct
##       check that opus-bitextsize works as it should also with untokenized files

ifdef SKIP_TOKENIZATION
  SELECTED_PACKAGES = ${ALG} ${LANG_RAW} ${MONO_RAW} $(MOSES) $(TMX)
endif

# file with all packages that can be distributed
PACKAGES := ${CORPUSPUB}/.packages


##----------------------------------------------------------------
## make release
##----------------------------------------------------------------

.PHONY: release release-packages packages
release release-packages packages: ${PACKAGES}
	${MAKE} ${CORPUSRELEASE}.info
	${MAKE} ${OPUSRELEASE}/${CORPUS}/info.txt
	${MAKE} ${OPUSRELEASE}/${CORPUS}/releases.txt
	${MAKE} ${CORPUSHOME}/releases.txt ${CORPUSHOME}/info.txt
	rsync -zav ${OPUSRELEASE}/${CORPUS}/*.info ${CORPUSHOME}/
	git add ${CORPUSHOME}/info.txt ${CORPUSHOME}/releases.txt ${CORPUSHOME}/*.info
	if [ `find ${OPUSRELEASE}/${CORPUS}/ -name 'index*.txt' | wc -l` -ne 0 ]; then \
	  rsync -zav ${OPUSRELEASE}/${CORPUS}/index*.txt ${CORPUSHOME}/; \
	  git add ${CORPUSHOME}/index*.txt; \
	fi

.PHONY: show-nrof-packages
show-nrof-packages:
	echo "nr of packages in release: $(words ${SELECTED_PACKAGES})"

.PHONY: show-packages
show-packages:
	@echo  "${notdir ${SELECTED_PACKAGES}}" | tr ' ' "\n"

##----------------------------------------------------------------
## submit individual SLURM jobs for creating release files
## (one for each language and language pair)
## 
## NOTE: you still need to run 'make release' afte all jobs are done!
## --> need to create info/release files and add files to git
## TODO: adjust job requirements depending on corpus size
## TODO: should we avoid moses/tmx files in massively multilingual corpora?
##----------------------------------------------------------------

LANGUAGE_RELEASE_JOBS := $(patsubst %,%-release-job,${LANGUAGES})
LANGPAIR_RELEASE_JOBS := $(patsubst %,%-release-job,${LANGPAIRS})

.PHONY: release-jobs mono-release-jobs para-release-jobs
.PHONY: ${LANGUAGE_RELEASE_JOBS} ${LANGPAIR_RELEASE_JOBS}

release-jobs: ${LANGUAGE_RELEASE_JOBS} ${LANGPAIR_RELEASE_JOBS}
mono-release-jobs: ${LANGUAGE_RELEASE_JOBS}
para-release-jobs: ${LANGPAIR_RELEASE_JOBS}

${LANGUAGE_RELEASE_JOBS}:
	${MAKE} HPC_MEM=16g HPC_CORES=2 HPC_DISK=200 EMAIL= $(@:-job=).submit

${LANGPAIR_RELEASE_JOBS}:
	@echo "submit $@ only if the required monolingual release files exist!"
	@if [ -e ${CORPUSRELEASE}/raw/$(firstword $(subst -, ,$(@:-release-job=))).zip ]; then \
	  if [ -e ${CORPUSRELEASE}/raw/$(lastword $(subst -, ,$(@:-release-job=))).zip ]; then \
	    if [ -e ${CORPUSRELEASE}/xml/$(firstword $(subst -, ,$(@:-release-job=))).zip ]; then \
	      if [ -e ${CORPUSRELEASE}/xml/$(lastword $(subst -, ,$(@:-release-job=))).zip ]; then \
	        ${MAKE} HPC_MEM=16g HPC_CORES=2 HPC_DISK=200 EMAIL= $(@:-job=).submit; \
	      fi \
	    fi \
	  fi \
	fi


##----------------------------------------------------------------
## publish the release
##----------------------------------------------------------------

.PHONY: publish-release
publish-release:
	${MAKE} upload
	${MAKE} info-yaml
	${MAKE} langid-mappings
	${MAKE} index-info
	${MAKE} upload-website
	${MAKE} upload-cwb
	${MAKE} upload-ida
	${MAKE} update-git
#	${MAKE} release-nlpl




## upload the release without adding the info to git yet

.PHONY: upload-release
upload-release:
	${MAKE} upload
	${MAKE} info-yaml
	${MAKE} langid-mappings
	${MAKE} index-info
	${MAKE} upload-website
	${MAKE} upload-cwb
#	${MAKE} release-nlpl


.PHONY: update-git
update-git:
	${MAKE} -C ${OPUSGITHOME} info
	cd ${OPUSGITHOME}   && git pull
	cd ${OPUSPUB}       && git pull
	cd ${CORPUSRELEASE} && find .  -maxdepth 1 -name 'README' -exec git add {} \;
	cd ${CORPUSRELEASE} && find .  -maxdepth 1 -name 'LICENSE' -exec git add {} \;
	cd ${CORPUSRELEASE} && find .  -maxdepth 1 -name 'INFO' -exec git add {} \;
	cd ${CORPUSRELEASE} && find .  -maxdepth 1 -name 'CONTACT*' -exec git add {} \;
	cd ${CORPUSRELEASE} && find .  -maxdepth 1 -name 'CITATION*' -exec git git add {} \;
	cd ${CORPUSRELEASE} && find .  -maxdepth 1 -name '*.yaml' -exec git add {} \;
	cd ${CORPUSRELEASE} && find .  -maxdepth 1 -name '*.txt' -exec git add {} \;
	cd ${CORPUSRELEASE} && find .  -maxdepth 1 -name '*.info' -exec git add {} \;
	cd ${CORPUSRELEASE} && find . -name '*.tsv' -exec git add {} \;
	-cd ${OPUSRELEASE}  && git add ${CORPUS}/.uploaded-${VERSION}
	-cd ${OPUSRELEASE}  && git add ${CORPUS}/.released-${VERSION}
	-cd ${OPUSRELEASE}  && git add ${CORPUS}/*.info ${CORPUS}/*.txt ${CORPUS}/*.txt
	cd ${OPUSPUB}       && git add ${CORPUS}/${VERSION}
	cd ${OPUSPUB}       && git add ${CORPUS}-${VERSION}.php ${CORPUS}.php
	cd ${OPUSGITHOME}   && git commit -am '${CORPUS} release ${VERSION} added'
	cd ${OPUSPUB}       && git commit -am '${CORPUS} release ${VERSION} added'
	cd ${OPUSGITHOME}   && git push
	cd ${OPUSPUB}       && git push



## create monolingual release file
LANGUAGE_RELEASE := $(patsubst %,%-release,${LANGUAGES})

.PHONY: ${LANGUAGE_RELEASE}
${LANGUAGE_RELEASE}:
	${MAKE} ${CORPUSRELEASE}/xml/${@:-release=}.zip \
		${CORPUSRELEASE}/raw/${@:-release=}.zip \
		${CORPUSRELEASE}/mono/${@:-release=}.txt.gz \
		${CORPUSRELEASE}/mono/${@:-release=}.tok.gz \
		${CORPUSPUB}/${@:-release=}_sample.html
	${MAKE} ${CORPUSRELEASE}/info/${@:-release=}.info \
		${CORPUSRELEASE}/freq/${@:-release=}.freq.gz



## create bitext release files
LANGPAIR_RELEASE := $(patsubst %,%-release,${LANGPAIRS})

.PHONY: ${LANGPAIR_RELEASE}
${LANGPAIR_RELEASE}:
	${MAKE} ${CORPUSRELEASE}/xml/${@:-release=}.xml.gz \
		${CORPUSRELEASE}/moses/${@:-release=}.txt.zip \
		${CORPUSRELEASE}/tmx/${@:-release=}.tmx.gz \
		${CORPUSPUB}/${@:-release=}_sample.html
	${MAKE} ${CORPUSRELEASE}/info/${@:-release=}.info \
		${CORPUSRELEASE}/info/${@:-release=}.txt.info \
		${CORPUSRELEASE}/info/${@:-release=}.tmx.info




## corpus info files
## TODO: statistics.yaml becomes too big for GitHub in massively multilingual corpora!
##       for example, in translatewiki (> 170MB)

.PHONY: info-yaml
info-yaml: ${OPUSRELEASE}/${CORPUS}/${VERSION}/info.yaml

${OPUSRELEASE}/${CORPUS}/${VERSION}/info.yaml: ${OPUSRELEASE}/${CORPUS}/${VERSION}.info
	${OPUSTOOLS}/info2yaml.pl -b ${OPUSRELEASE}/${CORPUS}
	cd ${OPUSRELEASE}/${CORPUS} && git add info.yaml ${VERSION}/*.yaml


## create a file for language ID mappings

.PHONY: lang-mappings
langid-mappings: ${OPUSRELEASE}/${CORPUS}/${VERSION}/language_mappings.tsv

ifdef ALL_LANGID_MAPPINGS
  LANGMAPPING_FILES = $(patsubst %/statistics.yaml,%/language_mappings.tsv,\
			$(wildcard ../releases/*/*/statistics.yaml))

  all-langid-mappings: ${LANGMAPPING_FILES}
endif

%/language_mappings.tsv: %/statistics.yaml
	@echo "make $@"
	@rm -f $@
	@for l in `grep 'mono/.*\.txt.gz' $< | sed 's|^.*/||' | cut -f1 -d. | sort -u`; do \
	  echo -n "$$l "; \
	  url=`grep "mono/$$l\.txt.gz" $< | sed 's/^.*url: //'`; \
	  script=`wget -qq -Q20k -O - $${url} | gzip -cd | head -20 | tr "\n" ' ' | langscript -l $$l -R -3`; \
	  code=`wget -qq -Q20k -O - $${url} | gzip -cd | head -20 | tr "\n" ' ' | langscript -l $$l -D -r -3`; \
	  echo "$$l	$${script}	$${code}" >> $@; \
	done
	@echo "done!"


# update the OPUS corpus index

.PHONY: index-info
index-info:
	rm -f ${OPUSRELEASE}/index-info.txt
	${MAKE} ${OPUSRELEASE}/index-info.txt

${OPUSRELEASE}/index-info.txt:
	find ${OPUSRELEASE}/ -name 'info.yaml' | sed 's#^${OPUSRELEASE}/##' | sort > $@


# upload release packages and websites to allas, IDA, OPUS server

.PHONY: upload
upload: ${PACKAGES}
	which a-get   ## to make sure that allas connections are set up
	${MAKE} -C ${OPUSHOME}/admin CORPUS=${CORPUS} VERSION=${VERSION} upload

.PHONY: upload-website
upload-website: ${SAMPLE_FILES} ${OPUSPUB}/${CORPUS}-${VERSION}.php ${OPUSPUB}/${CORPUS}.php
	${MAKE} -C ${OPUSHOME}/admin CORPUS=${CORPUS} VERSION=${VERSION} sync-html

.PHONY: upload-cwb
upload-cwb:
	if [ -d ${CWBREG}/${CORPUS}-${VERSION} ]; then \
	  ${MAKE} -C ${OPUSHOME}/admin CORPUS=${CORPUS} VERSION=${VERSION} sync-cwb; \
	fi

.PHONY: upload-ida
upload-ida: ${PACKAGES}
	${MAKE} -C ${OPUSHOME}/admin CORPUS=${CORPUS} VERSION=${VERSION} upload-ida


# release data in NLPL partition

.PHONY: release-nlpl
release-nlpl:
	if [ -d ${OPUSNLPL} ]; then \
	  if [ ${OPUSNLPL} != ${OPUSRELEASE} ]; then \
	    rsync -av --exclude='*'.tsv --exclude='info/*'.info ${OPUSRELEASE}/${CORPUS} ${OPUSNLPL}; \
	    rsync -av ${OPUSRELEASE}/index.txt ${OPUSNLPL}/; \
	    rm -f ${OPUSNLPL}/${CORPUS}/latest; \
	    cd ${OPUSNLPL}/${CORPUS} && ln -s ${VERSION} latest; \
	  fi \
	fi





# CES-align files for the current source language
# (can be used to distribute jobs - one per source language)

SRCSRC := $(wildcard ${CORPUSXML}/${SRC}-*.xml.gz)


# script for creating websites
MAKEHTML   := opus-website

## some scripts for conversion
TAB2TMX    := bitext2tmx
OPUS2MOSES := opus2bitext


## create directories with read permissions for everyone
MKDIR     := mkdir -p -m 755
LOCALTMP  := ${shell mktemp -d -p ${TMPDIR}}


.PHONY: html refresh-html download-dirs webpage website
html: 	${OPUSPUB}/${CORPUS}.php ${FREQ_COUNTS}
	cat ${PACKAGES} | sort | uniq > ${PACKAGES}.uniq
	mv -f ${PACKAGES}.uniq ${PACKAGES}

.PHONY: release-info
release-info: ${OPUSRELEASE}/${CORPUS}/releases.txt ${CORPUSHOME}/releases.txt

${OPUSRELEASE}/${CORPUS}/releases.txt: ${OPUSRELEASE}/${CORPUS}/info.txt
	echo '${VERSION}	${shell date}' >> $@
	rev $@ | tr ' ' '~' | uniq -f 1 | rev | tr '~' ' ' > $@.uniq
	mv -f $@.uniq $@

${CORPUSHOME}/releases.txt ${CORPUSHOME}/info.txt: ${CORPUSHOME}/%.txt: ${OPUSRELEASE}/${CORPUS}/%.txt
	rsync $< $@

.PHONY: release-uniq
release-uniq:
	rev ${OPUSRELEASE}/${CORPUS}/releases.txt | tr ' ' '~' | \
	uniq -f 1 | rev | tr '~' ' ' > ${OPUSRELEASE}/${CORPUS}/releases.uniq
	mv -f ${OPUSRELEASE}/${CORPUS}/releases.uniq ${OPUSRELEASE}/${CORPUS}/releases.txt


.PHONY: refresh-html
refresh-html:
	rm -f ${OPUSPUB}/${CORPUS}.php
	rm -f ${CORPUSPUB}/*sample.html
	touch $(CES)
	make html

.PHONY: refresh-website
refresh-website:
	cp  ${OPUSPUB}/${CORPUS}.php ${OPUSPUB}/${CORPUS}.php.backup
	cp  ${OPUSPUB}/${CORPUS}-${VERSION}.php ${OPUSPUB}/${CORPUS}-${VERSION}.php.backup
	rm -f ${OPUSPUB}/${CORPUS}.php ${OPUSPUB}/${CORPUS}-${VERSION}.php
	make website


.PHONY: download-dirs
download-dirs: ${CORPUSRELEASE}

.PHONY: webpage website
webpage website: ${OPUSPUB}/${CORPUS}.php

## create the release
${CORPUSRELEASE}:
	${MKDIR} $@
	${MKDIR} $@/xml $@/raw $@/mono 
	${MKDIR} $@/moses $@/tmx $@/smt 
	${MKDIR} $@/freq $@/dic
	${MAKE} PACKAGE="${CORPUS} in XML format" $@/xml/README
	${MAKE} PACKAGE="${CORPUS} in Moses format" $@/moses/README
	${MAKE} PACKAGE="${CORPUS} in TMX format" $@/tmx/README



## citation note to be added to website

#  CITENOTE=Please <a href="http://opus.lingfil.uu.se/RANLP_V.txt">cite the following article</a> if you use any part of the corpus in your own work:<br/> J\&ouml;rg Tiedemann, 2009, <a href="http://stp.lingfil.uu.se/~joerg/published/ranlp-V.pdf">News from OPUS - A Collection of Multilingual Parallel Corpora with Tools and Interfaces</a>. In N. Nicolov and K. Bontcheva and G. Angelova and R. Mitkov (eds.) Recent Advances in Natural Language Processing (vol V), pages 237-248, John Benjamins, Amsterdam/Philadelphia<br/>

ifndef CITENOTE
  CITENOTE=Please <a href="http://opus.lingfil.uu.se/LREC2012.txt">cite the following article</a> if you use the OPUS packages and downloads in your own work:<br/> J. Tiedemann, 2012, <a href="http://www.lrec-conf.org/proceedings/lrec2012/pdf/463_Paper.pdf"><i>Parallel Data, Tools and Interfaces in OPUS.</i></a> In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC 2012)<br/>
endif

## additional information about the downloads

ifdef LICENSE
  LICENSEINFO=<b>License:</b> ${LICENSE}<br/>
endif

ifdef COPYRIGHT
  COPYRIGHTINFO=<b>Copyright:</b> ${COPYRIGHT}<br/>
endif

ifndef DOWNLOADINFO
  DOWNLOADINFO=<p>Below you can download data files for all language pairs in different formats and with different kind of annotation (if available). You can click on the various links as explained below. In addition to the files shown on this webpage, OPUS also provides pre-compiled word alignments and phrase tables, bilingual dictionaries, frequency counts, and these files can be found through the <a href="/index.php">resources search form on the top-level website of OPUS</a>.</p><p>${LICENSEINFO}${COPYRIGHTINFO}</p>
endif

ifndef OTHERVERSIONS
  OTHERVERSIONS=<h3>Release history:</h3><p><ul>${shell find ${OPUSPUB}/ -name '${CORPUS}-v*.php' -printf "%f\n" | sort | sed 's/${CORPUS}-\(v.*\).php/<li><a href=\"${CORPUS}-\1.php\">${CORPUS} \1<\/a><\/li>/'}</ul></p>
endif

ifndef DISCLAIMER
  DISCLAIMER = <h3>Disclaimer</h3> \
<ul> \
<li>We do not own any of the text from which the data has been extracted.</li> \
<li>We only offer files that we believe we are free to redistribute. If any doubt occurs about the legality of any of our file downloads we will take them off right away after contacting us.</li> \
</ul> \
<h3>Notice and take down policy</h3> \
Notice: Should you consider that our data contains material that is owned by you and should therefore not be reproduced here, please: \
<ul> \
    <li>Clearly identify yourself, with detailed contact data such as an address, telephone number or email address at which you can be contacted.</li> \
    <li>Clearly identify the copyrighted work claimed to be infringed.</li> \
    <li>Clearly identify the material that is claimed to be infringing and information reasonably sufficient to allow us to locate the material.</li> \
    <li>And contact the OPUS project at the following email address: opus-project at helsinki.fi.</li>\
</ul> \
Take down: We will comply to legitimate requests by removing the affected sources from the next release of the corpus.
endif


print-release-history:
	@echo '${OTHERVERSIONS}'
	find ${OPUSPUB}/ -name '${CORPUS}-v*.php' -printf "%f\n"


# TODO: need to make those substituitons failsafe somehow
# now only replaces single quotes and escapes & to make sed happy

DOWNLOADINFO_SAFE = $(subst &,\&,$(subst ',&apos;,${DOWNLOADINFO}))
SRCHTML_SAFE      = $(subst &,\&,$(subst ',&apos;,${SRCHTML}))
EXTRAHTML_SAFE    = $(subst &,\&,$(subst ',&apos;,${EXTRAHTML}))
CITENOTE_SAFE     = $(subst &,\&,$(subst ',&apos;,${CITENOTE}))
DISCLAIMER_SAFE   = $(subst &,\&,$(subst ',&apos;,${DISCLAIMER}))
# '


${OPUSPUB}/${CORPUS}-${VERSION}.php: ${PACKAGES} ${CORPUS_SAMPLES} ${ALG_SAMPLES} ${INFOFILES}
	@${MKDIR} $(dir $@)
	@chmod 755 ${dir $@}
	@chmod 755 ${OPUSPUB}/${CORPUS}
	@chmod 755 ${OPUSPUB}/${CORPUS}/${VERSION}
	@${MAKEHTML} -h ${OPUSPUB} -o ${OPUSHOME} -d ${OPUSRELEASE} ${CORPUS} ${VERSION} |\
	sed -e 's|<h3>Download</h3>|<h3>Download</h3>${DOWNLOADINFO_SAFE}${EXTRAHTML_SAFE}${OTHERVERSIONS}|' \
	    -e 's|<h3>Download</h3>|${CITENOTE_SAFE}<h3>Download</h3>|' \
	    -e 's|<h1>${CORPUS}${VERSION}</h1>|<h1>${CORPUS} ${VERSION}</h1>${SRCHTML_SAFE}|' \
	    -e 's|<h1>${CORPUS}</h1>|<h1>${CORPUS} ${VERSION}</h1>${SRCHTML_SAFE}|' \
	    -e 's|<div class="footer">|${DISCLAIMER_SAFE}<div class="footer">|'          > $@
	@chmod 644 $@
	cd ${OPUSPUB} && git add $(notdir $@)
	cd ${OPUSPUB} && git add ${CORPUS}/${VERSION}


create-website-without-dependencies:
	@${MAKEHTML} -h ${OPUSPUB} -o ${OPUSHOME} -d ${OPUSRELEASE} ${CORPUS} ${VERSION} |\
	sed -e 's|<h3>Download</h3>|<h3>Download</h3>${DOWNLOADINFO_SAFE}${EXTRAHTML_SAFE}${OTHERVERSIONS}|' \
	    -e 's|<h3>Download</h3>|${CITENOTE_SAFE}<h3>Download</h3>|' \
	    -e 's|<h1>${CORPUS}${VERSION}</h1>|<h1>${CORPUS} ${VERSION}</h1>${SRCHTML_SAFE}|' \
	    -e 's|<h1>${CORPUS}</h1>|<h1>${CORPUS} ${VERSION}</h1>${SRCHTML_SAFE}|' \
	    -e 's|<div class="footer">|${DISCLAIMER_SAFE}<div class=\"footer\">|' > ${OPUSPUB}/${CORPUS}-${VERSION}.php


${OPUSPUB}/${CORPUS}.php: ${OPUSPUB}/${CORPUS}-${VERSION}.php
	@rm -f $@
	@( cd ${OPUSPUB}; ln -s $(notdir $<) $(notdir $@) )
	cd ${OPUSPUB} && git add $(notdir $@)


${PACKAGES}: ${CORPUSRELEASE} ${SELECTED_PACKAGES}
	@${MKDIR} ${dir $@}
	@rm -f ${CORPUSRELEASE}/README
	@${MAKE} ${CORPUSRELEASE}/LICENSE ${CORPUSRELEASE}/README
	@for s in ${LANGUAGES}; do \
	  for t in ${LANGUAGES}; do \
	    if [ -e ${CORPUSRELEASE}/xml/$$s-$$t.xml.gz ]; then \
	      echo "xml/$$s-$$t.xml.gz" >> $@; \
	    fi; \
	    if [ -e ${CORPUSRELEASE}/tmx/$$s-$$t.tmx.gz ]; then \
	      echo "tmx/$$s-$$t.tmx.gz" >> $@; \
	    fi; \
	    if [ -e ${CORPUSRELEASE}/moses/$$s-$$t.txt.zip ]; then \
	      echo "tmx/$$s-$$t.txt.zip" >> $@; \
	    fi; \
	  done \
	done
	@for f in $(patsubst ${OPUSRELEASE}/%,%,${LANG_XML}); do \
	  if [ -e ${OPUSRELEASE}/$$f ]; then echo $$f >> $@; fi \
	done
	@for f in $(patsubst ${OPUSRELEASE}/%,%,${LANG_RAW}); do \
	  if [ -e ${OPUSRELEASE}/$$f ]; then echo $$f >> $@; fi \
	done
	@for f in $(patsubst ${OPUSRELEASE}/%,%,${LANG_UD}); do \
	  if [ -e ${OPUSRELEASE}/$$f ]; then echo $$f >> $@; fi \
	done
	@for f in $(patsubst ${OPUSRELEASE}/%,%,${MONO_RAW}); do \
	  if [ -e ${OPUSRELEASE}/$$f ]; then echo $$f >> $@; fi \
	done
	@for f in $(patsubst ${OPUSRELEASE}/%,%,${MONO_TOK}); do \
	  if [ -e ${OPUSRELEASE}/$$f ]; then echo $$f >> $@; fi \
	done
	@for f in $(patsubst ${OPUSRELEASE}/%,%,${FREQ_COUNTS}); do \
	  if [ -e ${OPUSRELEASE}/$$f ]; then echo $$f >> $@; fi \
	done
	@cat ${PACKAGES} | sort | uniq > ${PACKAGES}.uniq
	@mv -f ${PACKAGES}.uniq ${PACKAGES}
	@echo "-----------------------------"      >> ${CORPUSRELEASE}/README
	@echo "xml ....... tokenized corpus and sentence alignments" >> ${CORPUSRELEASE}/README
	@echo "raw ....... untokenized corpus in XML" >> ${CORPUSRELEASE}/README
	@echo "mono ...... monolingual text files" >> ${CORPUSRELEASE}/README
	@if [ `find ${CORPUSRELEASE}/moses -name '*.zip' | wc -l` -gt 0 ]; then \
	  echo "moses ..... aligned plain text files" >> ${CORPUSRELEASE}/README; \
	fi
	@if [ `find ${CORPUSRELEASE}/moses -name '*.tmx.gz' | wc -l` -gt 0 ]; then \
	  echo "tmx ....... bitexts in TMX format" >> ${CORPUSRELEASE}/README; \
	fi
	@echo "freq ...... token frequencies"      >> ${CORPUSRELEASE}/README
	@if [ `find ${CORPUSRELEASE}/smt -type f | wc -l` -gt 0 ]; then \
	  echo "smt ....... word alignments and phrase translation tables" >> ${CORPUSRELEASE}/README; \
	fi
	@if [ `find ${CORPUSRELEASE}/dic -type f | wc -l` -gt 0 ]; then \
	  echo "dic ....... bilingual dictionaries extracted from word alignments" >> ${CORPUSRELEASE}/README; \
	fi
	@echo "-----------------------------"  >> ${CORPUSRELEASE}/README
	@echo "Files in this release"          >> ${CORPUSRELEASE}/README
	@echo "-----------------------------"  >> ${CORPUSRELEASE}/README
	@cat ${PACKAGES} | grep '/${VERSION}/' >> ${CORPUSRELEASE}/README




## generic target to create a README file

%/README:
	@echo " Corpus Name: ${CORPUS}"        >$@
ifneq (${PACKAGE},)
	@echo "     Package: ${PACKAGE}"      >>$@
endif
	@echo "     Website: http://opus.nlpl.eu/legacy/${CORPUS}-${VERSION}.php" >> $@
	@echo "     Release: ${VERSION}"      >>$@
ifneq (${RELEASE_DATE},)
	@echo "Release date: ${RELEASE_DATE}" >> $@
	@echo "   OPUS date: ${shell date}"   >> $@
else
	@echo "Release date: ${shell date}"   >> $@
endif
ifneq (${LICENSE},)
	@echo "     License: ${LICENSE}"      >>$@
endif
ifneq (${COPYRIGHT},)
	@echo "   Copyright: $(subst ",\",${COPYRIGHT})" >>$@          # escape "
endif
ifneq (${CONTACT},)
	@echo "     Contact: $(subst ",\",${CONTACT})" >>$@            # escape "
endif
ifneq (${SOURCE_URL},)
	@echo "      Source: ${SOURCE_URL}"   >>$@
endif
	@echo "" >>$@
	@echo "This package is part of OPUS - the open collection of parallel corpora" >> $@
	@echo "OPUS Website: http://opus.nlpl.eu" >> $@
	@echo "" >>$@
#	@echo "${CITENOTE}" | sed 's/<[^>]*>//g' >> $@
	@echo "$(subst ",\",${CITENOTE})" >> $@                        # escape "
	@echo "" >>$@
	@echo "$(subst ",\",${SRCHTML})"   | sed 's/<[^>]*>//g' >> $@  # escape " and remove HTML
	@echo "$(subst ",\",${EXTRAHTML})" | sed 's/<[^>]*>//g' >> $@  # escape " and remove HTML
	@if [ -e ${CORPUSHOME}/INFO ]; then \
	  echo ""                        >> $@; \
	  echo "Additional information:" >> $@; \
	  echo ""                        >> $@; \
	  cat ${CORPUSHOME}/INFO         >> $@; \
	fi
	@chmod 644 $@

%/LICENSE:
	@if [ -e ${CORPUSHOME}/LICENSE ]; then \
	  cp ${CORPUSHOME}/LICENSE $@; \
	elif [ -e ${CORPUSHOME}/LICENSE.pdf ]; then \
	  pdftotext -layout ${CORPUSHOME}/LICENSE.pdf; \
	  cp ${CORPUSHOME}/LICENSE.txt $@; \
	else \
	  echo "We do not own any of the text from which the data has been extracted." > $@; \
	  echo "We only offer files that we believe we are free to redistribute."     >> $@; \
	  echo "If any doubt occurs about the legality of any of our file downloads " >> $@; \
	  echo "we will take them off right away after contacting us."                >> $@; \
	  echo ""                                                                     >> $@; \
	  echo "For more information, please check the information"                   >> $@; \
	  echo "given on the corpus website: http://opus.nlpl.eu/${CORPUS}-${VERSION}.php" >> $@; \
	fi
	@chmod 644 $@



#----------------------------------------------------------------------------
## copy sentence alignment files
#----------------------------------------------------------------------------

.PHONY: alg_files
alg_files: ${ALG}

${ALG}: ${CORPUSRELEASE}/%: ${CORPUSHOME}/%
	@${MKDIR} ${dir $@}
	rsync $< $@
	chmod 644 $@

#----------------------------------------------------------------------------
# pack all language files in tar-archives
#----------------------------------------------------------------------------


# raw and tokenized monolingual XML-file packages
# for historical reasons: leave tar targets
.PHONY: lang_xml lang_tar lang_tok_tar
lang_xml lang_tar lang_tok_tar: ${LANG_XML}

.PHONY: lang_raw lang_raw_tar
lang_raw lang_raw_tar: ${LANG_RAW}


## create the tokenized and raw monolingual XML-file packages
## - either reuse existing zip files and add some info-files
## - or create a new zip archive (in TMPDIR) and move it to the release dir

# ${CORPUSRELEASE}/xml/%.zip ${CORPUSRELEASE}/raw/%.zip:
${LANG_RAW} ${LANG_XML}:
	@${MKDIR} $(dir $@)
	if [ -e $(patsubst ${CORPUSRELEASE}/%,${CORPUSHOME}/%,$@) ]; then \
	  rsync $(patsubst ${CORPUSRELEASE}/%,${CORPUSHOME}/%,$@) $@; \
	else \
	  ${MAKE} $(patsubst ${CORPUSRELEASE}/%,${TMPDIR}/${CORPUS}/%,$@); \
	  mv -f $(patsubst ${CORPUSRELEASE}/%,${TMPDIR}/${CORPUS}/%,$@) $@; \
	fi
	mkdir -p $@.d
	${MAKE} PACKAGE=$(patsubst ${CORPUSRELEASE}/%.zip,${CORPUS}/%,$@) $@.d/README $@.d/LICENSE
	echo "$(patsubst ${CORPUSRELEASE}/%.zip,${CORPUS}/%,$@)"  > $@.d/INFO
	echo "${CORPUS}"                                         >> $@.d/INFO
	echo "${VERSION}"                                        >> $@.d/INFO
	cd $@.d && zip -r $@ INFO README LICENSE
	find $@.d -delete
	chmod 644 $@


## create zip-file in temporary directory
## from the collection of individual files

${TMPDIR}/${CORPUS}/%.zip: ${CORPUSHOME}/%
	@${MKDIR} $(dir $@)
	rsync -a $< $(dir $@)
	find $(@:.zip=) -type l -delete
	find $(@:.zip=) -name '*.${XMLEXT}' | xargs -P ${THREADS} gunzip -f
	cd ${TMPDIR} && zip -r $@ $(patsubst ${TMPDIR}/%,%,$(@:.zip=))
	find $(@:.zip=) -delete






# parsed corpus files (not all languages need to be parsed)

.PHONY: lang_parsed lang_parsed_tar
lang_parsed lang_parsed_tar:
	for l in ${LANGUAGES}; do \
	  if [ -d ${CORPUSPARSED}/$$l ]; then \
	    ${MAKE} ${CORPUSRELEASE}/$$l.parsed.zip; \
	  fi; \
	done

${LANG_UD}: ${CORPUSRELEASE}/parsed/%.zip: ${CORPUSPARSED}/%
	@${MKDIR} ${dir $@}
	${MKDIR} ${TMPDIR}/$</${CORPUS}/parsed
	rsync -a $< ${TMPDIR}/$</${CORPUS}/parsed/
	find ${TMPDIR}/$</${CORPUS}/parsed -name '*.${XMLEXT}' |\
	xargs -P ${THREADS} gunzip -f
	${MAKE} PACKAGE=${patsubst ${OPUSCORPORA}/%,%,$<} ${TMPDIR}/$</README
	${MAKE} ${TMPDIR}/$</LICENSE
	echo "${patsubst ${OPUSCORPORA}/%,%,$<}" > ${TMPDIR}/$</INFO
	echo "${CORPUS}" >> ${TMPDIR}/$</INFO
	echo "${VERSION}" >> ${TMPDIR}/$</INFO
	( cd ${TMPDIR}/$<; zip -r $@ INFO README LICENSE ${CORPUS}; cd ${PWD} )
	rm -fr ${TMPDIR}/$<
	${MKDIR} ${dir ${PACKAGES}}
	echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
	chmod 644 $@

#----------------------------------------------------------------------------
# make monolingual plain text files
#----------------------------------------------------------------------------

.PHONY: mono_tok mono_raw
mono_tok: ${MONO_TOK}
mono_raw: ${MONO_RAW}


${MONO_TOK}: ${CORPUSRELEASE}/mono/%.tok.gz: ${CORPUSRELEASE}/xml/%.zip
	@${MKDIR} ${LOCALTMP}/mono/xml
	@rsync $< ${LOCALTMP}/mono/xml/
	opus-cat -t ${LOCALTMP}/mono/xml/$(notdir $<) \
	| ${GZIP} -c > ${LOCALTMP}/mono/xml/$(notdir $@)
	@${MKDIR} ${dir $@}
	@mv ${LOCALTMP}/mono/xml/$(notdir $@) $@
	@rm -f ${LOCALTMP}/mono/xml/$(notdir $<)
	@${MKDIR} ${dir ${PACKAGES}}
	@echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
	@chmod 644 $@

${MONO_RAW}: ${CORPUSRELEASE}/mono/%.txt.gz: ${CORPUSRELEASE}/raw/%.zip
	${MKDIR} ${LOCALTMP}/mono/raw
	@rsync $< ${LOCALTMP}/mono/raw/
	opus-cat -t ${LOCALTMP}/mono/raw/$(notdir $<) \
	| ${GZIP} -c > ${LOCALTMP}/mono/raw/$(notdir $@)
	@${MKDIR} ${dir $@}
	@mv ${LOCALTMP}/mono/raw/$(notdir $@) $@
	@rm -f ${LOCALTMP}/mono/raw/$(notdir $<)
	@${MKDIR} ${dir ${PACKAGES}}
	@echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
	@chmod 644 $@

# ${CORPUSRELEASE}/mono/%.tok.gz: ${CORPUSRELEASE}/xml/%.zip
# 	@${MKDIR} ${dir $@}
# 	opus-cat -t $< | ${GZIP} -c > $@
# 	${MKDIR} ${dir ${PACKAGES}}
# 	echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
# 	chmod 644 $@

# ${CORPUSRELEASE}/mono/%.txt.gz: ${CORPUSRELEASE}/raw/%.zip
# 	@${MKDIR} ${dir $@}
# 	opus-cat -t $< | ${GZIP} -c > $@
# 	${MKDIR} ${dir ${PACKAGES}}
# 	echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
# 	chmod 644 $@



## de-duplicated monolingual texts

# ${CORPUSRELEASE}/mono/%.dedup.gz: ${CORPUSRELEASE}/mono/%.txt.gz
%.dedup.gz: %.txt.gz
	${GZIP} -cd < $< | ${SORT} -u | ${GZIP} -c > $@


#----------------------------------------------------------------------------
# word frequency counts
#----------------------------------------------------------------------------

.PHONY: freq_counts
freq_counts: ${FREQ_COUNTS}

${FREQ_COUNTS}: ${CORPUSRELEASE}/freq/%.freq.gz: ${CORPUSRELEASE}/mono/%.tok.gz
	@${MKDIR} ${dir $@}
	${GZCAT} $< | \
	tr ' ' "\n" | \
	${SORT} | uniq -c | ${SORT} -nr | \
	${GZIP} -c > $@
	${MKDIR} ${dir ${PACKAGES}}
	echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
	chmod 644 $@

## Do we want to lower case all text?
## (counts before Aug 26, 2023 lower-cased everything before counting)
## --> but that can lead to some strange results

## lower-case only first character
##
#	sed "s/^\(.\)/\L\1/" |\

## use parallel to speed up (does this work?
##
#	${PARALLEL} sed "s/^\(.*\)$$/\L\1/" |\
#	${PARALLEL} tr ' ' "\n" | 

## not good enough for unicode:
#
#	tr '[:upper:]' '[:lower:]'


#----------------------------------------------------------------------------
# alignment sample files
#----------------------------------------------------------------------------

.PHONY: alg_samples
alg_samples: ${ALG_SAMPLES}

# -N '\/0\/' is used to filter out some strange files in OpenSubtitles2012
# which would be used for many sample files (year = 0)
# (they look messy and should actually be removed from the corpus)

ifndef UNSORTED_SENTALIGN

${ALG_SAMPLES}:  ${CORPUSPUB}/%_sample.html: ${CORPUSXML}/%.xml.gz
	@${MKDIR} ${dir $@}
	opus-read \
		-d ${CORPUSRAW} \
		-h -m 100 \
		-N '\/0\/' \
	$< > $@
	chmod 644 $@
else

${ALG_SAMPLES}: ${CORPUSPUB}/%_sample.html: ${CORPUSRELEASE}/tmx/%.tmx.gz
	@${MKDIR} ${dir $@}
	echo '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"' >$@
	echo '"http://www.w3.org/TR/REC-html40/loose.dtd">' >> $@
	echo '<html>' >> $@
	echo '<head>' >> $@
	echo '<title>Untitled Document</title>' >> $@
	echo '<meta http-equiv="Content-Type" content="text/html;charset=utf-8">' >> $@
	echo '</head>' >> $@
	echo '<body>' >> $@
	echo '<p>' >> $@
	zgrep '</tuv>' $< | \
	sed 's/^.*<seg>//;s#</seg> *</tuv>#<br/>#' |\
	head -100 |\
	sed ': loop; n; a <hr/>' >> $@
	echo '</body></html/>' >> $@
	chmod 644 $@

endif



.PHONY: corpus_samples
corpus_samples: ${CORPUS_SAMPLES}

${CORPUS_SAMPLES}:
	@${MKDIR} ${dir $@}
	echo '<html><head></head><body><pre>' >$@
	-opus-cat ${patsubst ${CORPUSPUB}/%_sample.html,${CORPUSXML}/%,$@} \
	| head -100 | recode utf8..utf16 | recode utf16..html >> $@
	echo '</pre></body></html>' >> $@
	chmod 644 $@



#----------------------------------------------------------------------------
# convert all bitexts to TMX
#----------------------------------------------------------------------------

# create TMX files from plain text files (Moses format)
# TMX files contain only unique translation units!
# --> use sort/uniq
# --> number alignments first to keep textual order!

tmx: ${CORPUSRELEASE} $(TMX)
	${MAKE} PACKAGE="${CORPUS} in TMX format" ${CORPUSRELEASE}/tmx/README

tmx-strict: ${CORPUSRELEASE} $(TMX_STRICT)

## only process bitexts with the current source language
srctmx:
	${MAKE} CES="${SRCCES}" tmx

## submit jobs for each 
srctmx-jobs:
	for l in ${LANGUAGES}; do \
	  rm -f srctmx.submit; \
	  ${MAKE} SRC=$$l srctmx.submit; \
	done


ifndef SKIP_TMX_UNIQ
   TMX_UNIQ = | nl | ${SORT} -k 2 | uniq -f 1 | ${SORT} -n | cut -f2,3
endif

$(TMX) $(TMX_STRICT): ${CORPUSRELEASE}/tmx/%.tmx.gz: ${CORPUSRELEASE}/moses/%.txt.zip
	@${MKDIR} ${dir $@}
	-( mkdir -p ${LOCALTMP}/tmx; \
	   cd ${LOCALTMP}/tmx; \
	   unzip $< -x README INFO LICENSE; \
	   S=$(firstword $(subst -, ,$(firstword $(subst ., ,$(notdir $<)))));\
	   T=$(lastword $(subst -, ,$(firstword $(subst ., ,$(notdir $<)))));\
	   BASE=${CORPUS}.$(patsubst %.txt.zip,%,$(notdir $<));\
	   SEXT=$$S; TEXT=$$T; \
	   if [ "$$SEXT" == "$$TEXT" ]; then SEXT=$${SEXT}1;TEXT=$${TEXT}2; fi; \
	   paste $$BASE.$$SEXT $$BASE.$$TEXT ${TMX_UNIQ} |\
	   $(TAB2TMX) -s $$S -t $$T |\
	   ${GZIP} -c > $@; \
	   rm -f $$BASE.$$SEXT $$BASE.$$TEXT $$BASE.ids $$BASE.xml; )
	${MKDIR} ${dir ${PACKAGES}}
	echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
	chmod 644 $@


## old:
#	  sed = - | sed 'N;s/\n/\t/' | sort -k 2 | uniq -f 1 | sort -n |\

#----------------------------------------------------------------------------
# convert all bitexts to Moses format
#----------------------------------------------------------------------------

.PHONY: moses
moses: $(MOSES)

## only process bitexts with the current source language
.PHONY: srcmoses
srcmoses:
	${MAKE} CES="${SRCCES}" moses

## submit jobs for each
.PHONY: srcmoses-jobs
srcmoses-jobs:
	for l in ${LANGUAGES}; do \
	  rm -f srcmoses.submit; \
	  ${MAKE} SRC=$$l srcmoses.submit; \
	done

## plain text bitexts with 1:1 sentence alignments
.PHONY: moses-strict
moses-strict: $(MOSES_STRICT)


## extract strict links with opus-read

${CORPUSRELEASE}/xml/%.strict.xml.gz: ${CORPUSXML}/%.xml.gz
	@${MKDIR} ${dir $@}
	opus-read -c 1 -S 1 -T 1 -l $< | gzip -c > $@


## convert XML to moses files

$(MOSES) $(MOSES_STRICT): ${CORPUSRELEASE}/moses/%.txt.zip: ${CORPUSRELEASE}/xml/%.xml.gz
	@mkdir -p ${TMPDIR}/$@.d
	@( S=$(firstword $(subst -, ,$(firstword $(subst ., ,$(notdir $<)))));\
	   T=$(lastword $(subst -, ,$(firstword $(subst ., ,$(notdir $<)))));\
	   echo "copy source ($$S) and target ($$T) language files to tmp"; \
	   for L in $$S $$T; do \
	     if [ -e ${CORPUSRELEASE}/raw/$$L.zip ]; then \
	       echo "rsync ${CORPUSRELEASE}/raw/$$L.zip ${TMPDIR}/$@.d/"; \
	       rsync ${CORPUSRELEASE}/raw/$$L.zip ${TMPDIR}/$@.d/; \
	     elif [ -e ${CORPUSRAW}/$$L.zip ]; then \
	       echo "rsync ${CORPUSRAW}/$$L.zip ${TMPDIR}/$@.d"; \
	       rsync ${CORPUSRAW}/$$L.zip ${TMPDIR}/$@.d/; \
	     elif [ -e ${CORPUSRAW}/$$L ]; then \
	       echo "rsync -a ${CORPUSRAW}/$$L ${TMPDIR}/$@.d/"; \
	       rsync -a ${CORPUSRAW}/$$L ${TMPDIR}/$@.d/; \
	     fi \
	   done; \
	   F=${CORPUS}.$(notdir $(@:.txt.zip=)); \
	   if [ "$$S" == "$$T" ]; then S=$${S}1;T=$${T}2; fi; \
	   ${GZCAT} $< \
	   | $(OPUS2MOSES) -v -r -d ${TMPDIR}/$@.d \
				-e ${TMPDIR}/$@.d/$$F.$$S \
				-f ${TMPDIR}/$@.d/$$F.$$T \
				-b ${TMPDIR}/$@.d/$$F.xml; \
	   ${MAKE} PACKAGE="${CORPUS}.$$S-$$T in Moses format" ${TMPDIR}/$@.d/README ${TMPDIR}/$@.d/LICENSE; \
	   zip -j ${TMPDIR}/$@ ${TMPDIR}/$@.d/README ${TMPDIR}/$@.d/LICENSE \
		${TMPDIR}/$@.d/$$F.$$S ${TMPDIR}/$@.d/$$F.$$T ${TMPDIR}/$@.d/$$F.xml; \
	   find ${TMPDIR}/$@.d -delete; )
	@mkdir -p $(dir $@)
	@mv -f ${TMPDIR}/$@ $@
	@echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
	@chmod 644 $@





.PHONY: smt
smt: ${WORDALG} ${SMT}

smt-test:
	echo ${WORDALG}
	echo ${SMT}

.PHONY: wordalg
wordalg: ${WORDALG}

## a zip file of word alignments (including corpus files)
${WORDALG}: ${CORPUSRELEASE}/smt/%.alg.zip: ${CORPUSWORDALIGN}/% # ${CORPUSWORDALIGN}/%/bitext.xml.gz
	${MKDIR} ${dir $@}
	${MKDIR} ${TMPDIR}/$@/${CORPUS}/smt/${notdir $<}
	rsync -a \
		--exclude '*\.wordalign*' \
		--exclude '*/lex.*' \
		--exclude '*/phrase*' \
		--exclude 'c.*' \
		--exclude '*/c.*' \
		$</ ${TMPDIR}/$@/${CORPUS}/smt/${notdir $<}
	find ${TMPDIR}/$@/${CORPUS}/smt -type f -name '*.gz' |\
	xargs -P 8 gunzip -f
	${MAKE} PACKAGE=${patsubst ${OPUSRELEASE}/%.zip,%,$@} ${TMPDIR}/$@/README
	rm -f $@
	( cd ${TMPDIR}/$@; zip -r $@ README ${CORPUS}; cd ${PWD} )
	rm -fr ${TMPDIR}/$@
	${MKDIR} ${dir ${PACKAGES}}
	echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
	chmod 644 $@


.PHONY: pt
pt: ${SMT}

## a zip file of SMT phrase translation tables
${SMT}: ${CORPUSRELEASE}/smt/%.zip: ${CORPUSWORDALIGN}/%
	${MKDIR} ${dir $@}
	${MKDIR} ${TMPDIR}/$@/${CORPUS}/smt/${notdir $<}
	rsync -a \
		--include '*/lex.*' \
		--include '*/phrase*' \
		--include="*/" \
		--exclude="*" \
		$</ ${TMPDIR}/$@/${CORPUS}/smt/${notdir $<}
	find ${TMPDIR}/$@/${CORPUS}/smt -type f -name '*.gz' |\
	xargs -P 8 gunzip -f
	${MAKE} PACKAGE=${patsubst ${OPUSRELEASE}/%.zip,%,$@} ${TMPDIR}/$@/README
	rm -f $@
	( cd ${TMPDIR}/$@; zip -r $@ README ${CORPUS}; cd ${PWD} )
	rm -fr ${TMPDIR}/$@
	${MKDIR} ${dir ${PACKAGES}}
	echo "$@" | sed "s#${OPUSRELEASE}/##" >> ${PACKAGES}
	chmod 644 $@


.PHONY: dic-release
dic-release: ${DIC}
${DIC}: ${CORPUSRELEASE}/%: ${CORPUSHOME}/%
	@${MKDIR} ${dir $@}
	rsync $< $@
	chmod 644 $@


## delete some packages that have no phrase table
SMTFIX = ${patsubst %.zip,%.fix,${SMT}}
smtfix: ${SMTFIX}

${SMTFIX}: ${CORPUSRELEASE}/smt/%.fix: ${CORPUSWORDALIGN}/%
	@if [ ! -e $</model/phrase-table-filtered.gz ]; then \
	  if [ -e ${patsubst %.fix,%.zip,$@} ]; then \
	    rm -f ${patsubst %.fix,%.zip,$@}; \
	  fi \
	fi



# ## fix broken links
# ${CORPUSWORDALIGN}/%:
# 	if [ -L $@ ] && [ ! -e $@ ]; then \
# 	  if [ -d ${CORPUSRELEASE}/wordalign/${notdir $@} ]; then \
# 	    rm -f $@; \
# 	    mv ${CORPUSRELEASE}/wordalign/${notdir $@} $@; \
# 	  fi \
# 	fi


# create bitext info files (some basic statistics)

.PHONY: info lang_info ces_info txt_info tmx_info
info: lang_info ces_info txt_info tmx_info
	${MAKE} ${CORPUSRELEASE}.info
	${MAKE} ${OPUSRELEASE}/${CORPUS}/info.txt

info-files: lang_info ces_info txt_info tmx_info

lang_info: ${LANG_INFO}



## if we skip tokenisation, then do a very simple word count

ifdef SKIP_TOKENIZATION

${LANG_INFO}: ${CORPUSRELEASE}/info/%.info: ${CORPUSRELEASE}/raw/%.zip
	${MKDIR} ${dir $@}
	opus-cat -l $< | wc -l > $@
	opus-cat    $< | grep '</s>' | wc -l >> $@
	opus-cat    $< | sed 's/<[^>]*>//g' | wc -w >> $@
	chmod 644 $@

else

${LANG_INFO}: ${CORPUSRELEASE}/info/%.info: ${CORPUSRELEASE}/raw/%.zip ${CORPUSRELEASE}/xml/%.zip
	${MKDIR} ${dir $@}
	opus-cat -l $< | wc -l > $@
	opus-cat    $< | grep '</s>' | wc -l >> $@
	opus-cat    $(word 2,$^) | grep '</w>' | wc -l >> $@
	chmod 644 $@

endif


ces_info: ${CES_INFO}
ces_info_file: ${CORPUSRELEASE}/info/${LANGPAIR}.info


ifdef SKIP_TOKENIZATION

${CES_INFO}: ${CORPUSRELEASE}/info/%.info: ${CORPUSRELEASE}/raw/%.xml.gz
	mkdir -p ${dir $@}
	${GZCAT} $< | opus-bitextsize -d ${CORPUSRAW} > $@
	chmod 644 $@

else

## NEW: use opus-bitextsize to get those counts
## NEW: create word count files to make it more efficient
## TODO: should we do any of this in some local tmpdir?
${CES_INFO}: ${CORPUSRELEASE}/info/%.info: ${CORPUSRELEASE}/xml/%.xml.gz log/.bitext-word-counts
	mkdir -p ${dir $@}
	${GZCAT} $< |\
	opus-bitextsize -d ${CORPUSXML} > $@
	chmod 644 $@

endif

## make word count files for each corpus file
## if we don't have too many (>=10000) of them
log/.bitext-word-counts:
	( n=`find ${CORPUSXML} -mindepth 2 -name '*.xml.gz' -not -empty | head -10000 | wc -l`; \
	  if [ $$n -gt 0 ] && [ $$n -lt 10000 ]; then \
	    find ${CORPUSXML} -mindepth 2 -name '*.xml.gz' | \
	    sed 's/\.xml\.gz$$/.counts.gz/' | \
	    xargs -P ${THREADS} ${MAKE}; \
	  fi )
	mkdir -p $(dir $@)
	touch $@


## save word counts to support making info files above
${CORPUSXML}/%.counts.gz: ${CORPUSXML}/%.xml.gz
	@mkdir -p ${dir $@}
	${GZIP} -cd < $< | opus-countwords | grep . | gzip -c > $@


log/.bitext-word-count-dbs:
	@mkdir -p ${dir $@}
	find ${CORPUSXML} -mindepth 2 -name '*.counts.gz' | \
	sed 's/\.counts\.gz$$/.cdb/' | \
	xargs -P ${THREADS} ${MAKE}
	touch $@

${CORPUSXML}/%.cdb: ${CORPUSXML}/%.counts.gz
	${GZCAT} $< |\
	perl ~/research/OpusTools-perl/scripts/admin/opus-tsv2cdb $@


txt_info: ${TXT_INFO}

${TXT_INFO}: ${CORPUSRELEASE}/info/%.txt.info: ${CORPUSRELEASE}/moses/%.txt.zip
	${MKDIR} ${dir $@}
	-( mkdir -p ${LOCALTMP}; \
	   cd ${LOCALTMP}; \
	   unzip -d . $< -x README INFO LICENSE; \
	   S=$(firstword $(subst -, ,$(firstword $(subst ., ,$(notdir $<)))));\
	   T=$(lastword $(subst -, ,$(firstword $(subst ., ,$(notdir $<)))));\
	   P=$$S-$$T; \
	   if [ "$$S" == "$$T" ]; then S=$${S}1;T=$${T}2; fi; \
	   if [ ! -e ${CORPUS}.$$P.$$S ]; then \
		find home -name "*$$P.$$S" -exec mv {} ${CORPUS}.$$P.$$S \; ; \
		find home -name "*$$P.$$T" -exec mv {} ${CORPUS}.$$P.$$T \; ; \
		rm -f $< ;\
		zip $< ${CORPUS}.$$P.$$S ${CORPUS}.$$P.$$T; \
	   fi; \
	   wc -l < ${CORPUS}.$$P.$$S > $(CORPUSRELEASE)/info/$$P.txt.info; \
	   wc -w < ${CORPUS}.$$P.$$S >> $(CORPUSRELEASE)/info/$$P.txt.info; \
	   wc -w < ${CORPUS}.$$P.$$T >> $(CORPUSRELEASE)/info/$$P.txt.info; \
	   rm -f *$$P.$$S *$$P.$$T *$$P.ids *$$P.xml; )
	chmod 644 $@


tmx_info: ${TMX_INFO}

${TMX_INFO}: ${CORPUSRELEASE}/info/%.tmx.info: ${CORPUSRELEASE}/tmx/%.tmx.gz
	${MKDIR} ${dir $@}
	( S=$(firstword $(subst -, ,$(firstword $(subst ., ,$(notdir $<)))));\
	  T=$(lastword $(subst -, ,$(firstword $(subst ., ,$(notdir $<)))));\
	 zgrep '</tu>' $< | wc -l > $@; \
	 zgrep "xml:lang=\"$$S\"" $< | \
	  	sed 's|^.*<seg>||;s|</seg>.*$$||;' | \
	  	wc -w >> $@; \
	 zgrep "xml:lang=\"$$T\"" $< | \
	  	sed 's|^.*<seg>||;s|</seg>.*$$||;' | \
	  	wc -w >> $@; )
	chmod 644 $@

## TODO: is it enough to check whether the info dir exists?
${OPUSRELEASE}/%.info: ${OPUSRELEASE}/%
	if [ -e $@ ]; then cp $@ $@.$(shell date +%F); fi
	${MAKE} info-files
	if [ -d $(@:.info=/info) ]; then \
	  cd ${OPUSRELEASE}; \
	  find ${patsubst ${OPUSRELEASE}/%.info,%/info,$@} -name '*.info' | sort |\
	  xargs grep . > $@; \
	fi


## TODO: do we need to download the old info file first?
${OPUSRELEASE}/${CORPUS}/info.txt: $(wildcard ${OPUSRELEASE}/${CORPUS}/*.info)
	cat $^ > $@

#	cat ${OPUSRELEASE}/${CORPUS}/*.info > $@.new
#	cat $@ $@.new | sort -k1,1 -k2,2n -t: -u > $@.merged
#	mv $@.merged $@
#	rm -f $@.new

delete-empty-bitexts:
	mkdir -p ${CORPUSHOME}/DELETE/xml
	for s in ${LANGUAGES}; do \
	  for t in ${LANGUAGES}; do \
	    if [ -e ${CORPUSXML}/$$s-$$t.xml.gz ]; then \
	      if [ `zgrep xtargets ${CORPUSXML}/$$s-$$t.xml.gz | head -10 | wc -l` == "0" ]; then \
		echo "empty bitext: $$s-$$t"; \
		mv -f ${CORPUSXML}/$$s-$$t.xml.gz ${CORPUSHOME}/DELETE/xml/; \
		rm -f ${CORPUSRELEASE}/xml/$$s-$$t.xml.gz; \
		rm -f ${CORPUSRELEASE}/moses/$$s-$$t.txt.zip; \
		rm -f ${CORPUSRELEASE}/dic/$$s-$$t.dic.gz; \
		rm -f ${CORPUSRELEASE}/smt/$$s-$$t.zip; \
		rm -f ${CORPUSRELEASE}/smt/$$s-$$t.alg.zip; \
		rm -f ${CORPUSRELEASE}/info/$$s-$$t.*info; \
	      fi \
	    fi; \
	    for f in 	${CORPUSRELEASE}/moses/$$s-$$t.txt.zip \
			${CORPUSRELEASE}/dic/$$s-$$t.dic.gz \
			${CORPUSRELEASE}/smt/$$s-$$t.zip \
			${CORPUSRELEASE}/smt/$$s-$$t.alg.zip; do \
	      if [ -e $$f ]; then \
	        if [ ! -e ${CORPUSXML}/$$s-$$t.xml.gz ]; then \
		  echo "delete extra file $$f"; \
		  rm -f $$f; \
		  rm -f ${CORPUSRELEASE}/info/$$s-$$t.*info; \
	        fi \
	      fi; \
	    done; \
	    if [ -e ${CORPUSRELEASE}/xml/$$s-$$t.xml.gz ]; then \
	      if [ `zgrep xtargets ${CORPUSRELEASE}/xml/$$s-$$t.xml.gz | head -10 | wc -l` == "0" ]; then \
		echo "empty bitext: $$s-$$t"; \
		rm -f ${CORPUSRELEASE}/xml/$$s-$$t.xml.gz; \
		rm -f ${CORPUSRELEASE}/moses/$$s-$$t.txt.zip; \
		rm -f ${CORPUSRELEASE}/dic/$$s-$$t.dic.gz; \
		rm -f ${CORPUSRELEASE}/smt/$$s-$$t.zip; \
		rm -f ${CORPUSRELEASE}/smt/$$s-$$t.alg.zip; \
		rm -f ${CORPUSRELEASE}/info/$$s-$$t.*info; \
	      fi \
	    fi; \
	  done \
	done
	${MAKE} delete-empty-sample-files

delete-empty-corpora:
	mkdir -p ${CORPUSHOME}/DELETE/xml
	mkdir -p ${CORPUSHOME}/DELETE/raw
	mkdir -p ${CORPUSHOME}/DELETE/parsed
	for s in ${LANGUAGES}; do \
	    if [ -e ${CORPUSRELEASE}/mono/$$s.txt.gz ]; then \
	      if [ `zcat ${CORPUSRELEASE}/mono/$$s.txt.gz | head | wc -l` == "0" ]; then \
		echo "empty corpus: $$s"; \
		rm -f ${CORPUSRELEASE}/mono/$$s.txt.gz; \
		rm -f ${CORPUSRELEASE}/mono/$$s.tok.gz; \
		rm -f ${CORPUSRELEASE}/info/$$s.info; \
		rm -f ${CORPUSRELEASE}/freq/$$s.freq.gz; \
		rm -f ${CORPUSRELEASE}/parsed/$$s.zip; \
		rm -f ${CORPUSRELEASE}/raw/$$s.zip; \
		rm -f ${CORPUSRELEASE}/xml/$$s.zip; \
		rm -f ${CORPUSRELEASE}/truecaser/$$s.gz; \
		if [ -d ${CORPUSHOME}/xml/$$s ]; then \
		  mv -f ${CORPUSHOME}/xml/$$s ${CORPUSHOME}/DELETE/xml/; \
		fi; \
		if [ -d ${CORPUSHOME}/raw/$$s ]; then \
		  mv -f ${CORPUSHOME}/raw/$$s ${CORPUSHOME}/DELETE/raw/; \
		fi; \
		if [ -d ${CORPUSHOME}/parsed/$$s ]; then \
		  mv -f ${CORPUSHOME}/parsed/$$s ${CORPUSHOME}/DELETE/parsed/; \
		fi; \
	      fi \
	    fi \
	done


delete-empty-sample-files:
	for s in ${LANGUAGES}; do \
	  if [ -e ${CORPUSPUB}/$$s\_sample.html ]; then \
	    if [ ! -e ${CORPUSRELEASE}/xml/$$s.zip ]; then \
		echo "delete sample for $$s"; \
		rm -f ${CORPUSPUB}/$$s\_sample.html; \
	    fi \
	  fi; \
	  for t in ${LANGUAGES}; do \
	    if [ -e ${CORPUSPUB}/$$s-$$t\_sample.html ]; then \
	      if [ ! -e ${CORPUSRELEASE}/xml/$$s-$$t.xml.gz ]; then \
		echo "delete sample for $$s-$$t"; \
		rm -f ${CORPUSPUB}/$$s-$$t\_sample.html; \
	      fi \
	    fi \
	  done; \
	done
